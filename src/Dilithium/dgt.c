#include <stdint.h>
#include <inttypes.h>
#include "params.h"
#include "dgt.h"
#include "reduce.h"

/* Inverse of the powers of an k-th root of i times the Montgomery constant R = 2^32 mod p and the inverse of n/2 modulo p. */
static const uint32_t invnthroots[N] = {83956, 0, 5071286, 6691010, 5194966, 613732, 3685658, 2107030, 6363626, 5298895, 3137621, 8294364, 655488, 7890779, 3034389, 7175704, 5858479, 1863887, 1951069, 6987030, 1319910, 833456, 4018757, 3382589, 1892397, 3805139, 3650046, 7919735, 1492975, 7904364, 8250392, 6333119, 1620543, 4720295, 6668349, 7973856, 7898458, 5833943, 4344758, 83427, 4559279, 2845396, 1017909, 3646408, 771551, 4368187, 1195024, 5169656, 7917791, 6045101, 7793948, 5681367, 7461066, 1054571, 2508264, 145631, 1419805, 5778720, 5923208, 8237883, 1991066, 3321686, 1389529, 8370904, 7266465, 5693825, 2937345, 567952, 1448421, 2166860, 4799867, 4535729, 2430476, 2036728, 3087054, 7758412, 5268295, 8041439, 4113413, 5463168, 196898, 2361761, 6536355, 4523831, 4619474, 243751, 4191948, 6634706, 5062330, 7999958, 2862296, 8188015, 6283816, 3722550, 2676856, 2860899, 7163742, 1570547, 371164, 5067592, 6078142, 1804712, 7481824, 4563849, 6115950, 3508072, 1764087, 598785, 2099722, 3859697, 7785954, 6968993, 3181707, 8312365, 4276509, 1648663, 3309724, 6819679, 3001345, 3202958, 1623416, 198960, 6071262, 171043, 5684738, 3151826, 2261269, 3110129, 4130825, 4249592, 7898546, 3070104, 1406917, 99375, 657719, 4990971, 2627546, 595937, 5231386, 3472499, 4102147, 5936579, 699627, 3710199, 6163677, 6023249, 6542075, 7681160, 159140, 6882132, 1238674, 3271261, 2684272, 6652282, 8097152, 721548, 5084499, 8000156, 6978754, 2622675, 1570547, 7163742, 4157974, 980194, 6074188, 2332037, 3116499, 7310877, 2804628, 5304195, 5818481, 8070678, 4760066, 4072651, 3048475, 1313203, 3562463, 3545861, 4362959, 158135, 8138838, 7123077, 6367568, 809142, 5772828, 2445100, 109126, 5176297, 2577922, 8236802, 7688194, 6116777, 2686592, 1113952, 6674410, 6266445, 7808421, 4308759, 5766165, 4343798, 7048776, 1482124, 7436148, 8166388, 8090586, 5296958, 6914473, 2589125, 185652, 1766032, 3685992, 4851881, 913821, 6819625, 4042227, 2783323, 3407111, 3814890, 7139283, 1175724, 7088363, 5150877, 2919716, 382744, 4720295, 1620543, 4440661, 7130600, 4481004, 6936279, 6074600, 6237921, 1987333, 637, 7082042, 5334766, 2956459, 910485, 8026776, 4616184, 3845552, 6585992, 6016732, 7353465, 6644134, 5519901, 4503931, 6319039, 7262310, 7856733, 2137590, 1567396, 4873795, 5773158, 8235815, 5510316};
/* Roots of unity in order needed by forward DGT */
static const uint32_t gj[N/4] = {4193792, 25847, 2608894, 518909, 777960, 237124, 466468, 876248, 2091905, 8021166, 6554070, 6026966, 5268920, 5700314, 5495562, 5260684, 6271868, 5760665, 7830929, 7260833, 1024112, 5654953, 4794489, 7300517, 8360995, 6623180, 8100412, 4010497, 6980856, 5102745, 3859737, 6262231, 2348700, 7841118, 300467, 3539968, 4519302, 5336701, 4805995, 2867647, 3077325, 3530437, 8284641, 2706023, 4464978, 5842901, 1661693, 3592148, 7426187, 4499374, 531354, 7568473, 5582638, 6308525, 3900724, 5823537, 4873154, 2140649, 6779997, 3699596, 4558682, 4874723, 6681150, 6736599};
/* Roots of unity in order needed by inverse DGT */
static const uint32_t invgj[N/4] = {4193792, 8354570, 7861508, 5771523, 7504169, 7913949, 8143293, 7602457, 3119733, 2884855, 2680103, 3111497, 2353451, 1826347, 359251, 6288512, 2118186, 4520680, 3277672, 1399561, 4369920, 280005, 1757237, 19422, 1079900, 3585928, 2725464, 7356305, 1119584, 549488, 2619752, 2108549, 1643818, 1699267, 3505694, 3821735, 4680821, 1600420, 6239768, 3507263, 2556880, 4479693, 2071892, 2797779, 811944, 7849063, 3881043, 954230, 4788269, 6718724, 2537516, 3915439, 5674394, 95776, 4849980, 5303092, 5512770, 3574422, 3043716, 3861115, 4840449, 8079950, 539299, 6031717};

/*************************************************
* Name:        dgt
*
* Description: Forward DGT, in-place. No modular reduction is performed after
*              additions or subtractions. If input coefficients are below 2*Q,
*              then output coefficients are below 18*Q.
*              Output vector is in bitreversed order.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/
void dgt(uint32_t p[N]) {
  int m, distance;
  int j1, j2, j, k;
  uint32_t a, temp_re, temp_img;
  
  distance = N/2;
  for(m = 1; m < N/2; m <<= 1) {
    for(k = 0; k < m; ++k) {
      j1 = k*distance << 1;
      j2 = j1+distance-1;

      a = gj[k];
      for(j = j1; j <= j2; j = j+2) {
        temp_re = montgomery_reduce((uint64_t)a * p[j+distance]);
        temp_img = montgomery_reduce((uint64_t)a * p[j+distance+1]);

        p[j+distance] = p[j] + 2*Q - temp_re;
        p[j+distance+1] = p[j+1]+ 2*Q - temp_img;
        
        p[j] = p[j] + temp_re;
        p[j+1] = p[j+1] + temp_img;
      }
    }
    distance >>= 1;
  }
}

/*************************************************
* Name:        invdgt_tomont
*
* Description: Inverse DGT and multiplication by Montgomery factor 2^32.
*              In-place. No modular reductions after additions or
*              subtractions. Input coefficient need to be smaller than 2*Q.
*              Output coefficient are smaller than 2*Q.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/
void invdgt_tomont(uint32_t x[N])
{
  int m, distance;
  int j1, j2, j, k;
  uint32_t a, a_re, a_img, sub_re, sub_img;
  uint32_t p[N];

  m = N/4;
  for(distance = 2; distance < N/2; distance <<= 1)
  {
    for(k = 0; k < m; ++k)
    {
      j1 = 2 * k * distance;
      j2 = j1 + distance - 1;

      a = invgj[k];
      for(j = j1; j <= j2; j += 2)
      {
        sub_re = x[j] + 256*Q - x[j+distance];
        sub_img = x[j+1] +  256*Q - x[j+distance+1];
        
        x[j] = x[j] + x[j+distance];
        x[j+1] = x[j+1] + x[j+distance+1];

        x[j+distance] = montgomery_reduce((uint64_t)a * sub_re);
        x[j+distance+1] = montgomery_reduce((uint64_t)a * sub_img);
      }
    }
    m >>= 1;
  }

  for(j = 0; j < N; ++j)
    p[j] = x[j];

  a = 0;
  for(j = 0; j < N/2; j += 2)
  {
    sub_re = p[j] + 256*Q - p[j+N/2];
    sub_img = p[j+1] +  256*Q - p[j+N/2+1];
    
    a_re = p[j] + p[j+N/2];
    a_img = p[j+1] + p[j+N/2+1];

    x[a] = freeze(montgomery_reduce((uint64_t)a_re * invnthroots[j]) + (2*Q - 
                  montgomery_reduce((uint64_t)a_img * invnthroots[j+1])));
    x[a+N/2] = freeze(montgomery_reduce((uint64_t)a_re * invnthroots[j+1] + (uint64_t)a_img * invnthroots[j]));    
    x[a+N/4] = freeze(montgomery_reduce((uint64_t)sub_re * invnthroots[j+N/2]) + (2*Q - 
                      montgomery_reduce((uint64_t)sub_img * invnthroots[j+N/2+1])));
    x[a+N/2+N/4] = freeze(montgomery_reduce((uint64_t)sub_re * invnthroots[j+N/2+1] + (uint64_t)sub_img * invnthroots[j+N/2]));
    
    a++;
  }
}